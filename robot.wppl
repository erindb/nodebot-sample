// webppl robot.wppl --require robot

display('start');

var connect = robot.connect;
connect();

<<<<<<< Updated upstream
var getLeftDistance = robot.getLeftDistance;
var getRightDistance = robot.getRightDistance;

=======
<<<<<<< Updated upstream
>>>>>>> Stashed changes
var secPerFullTurn = 8.75;
var turnPerSec = secPerFullTurn / (2*Math.PI);

var updatePosition = function(position, robotCommand, delay) {
	if (robotCommand=='moveForward') {
		return {
			x: position.x + Math.cos(position.theta),
			y: position.y + Math.sin(position.theta),
			theta: position.theta
		}
	} else if (robotCommand=='moveReverse') {
		return {
			x: position.x + Math.cos(position.theta),
			y: position.y + Math.sin(position.theta),
			theta: position.theta
		}
	} else if (robotCommand=='turnLeft') {
		return {
			x: position.x,
			y: position.y,
			theta: position.theta + turnPerSec*delay
		}
	} else if (robotCommand=='turnRight') {
		return {
			x: position.x,
			y: position.y,
			theta: position.theta - turnPerSec*delay
		}
	} else {
		return position;
	}
}

Infer({method: 'enumerate'}, function() {return {x:0, y:0, theta:0};});

var move = function(n, positionDist) {
	var positionDist = positionDist?positionDist:initialPosDist;
	var ldistance = getLeftDistance();
	var rdistance = getRightDistance();


	var marginalCommandsDist = Infer(
		{method: 'enumerate', samples: 1},
		function() {
			var position = sample(positionDist);

			// sample robot commands
			var delay = (randomInteger(10)+1)/10;
			var robotCommand = uniformDraw([
				'moveForward',
				'turnRight',
				'turnLeft',
				'moveReverse',
				'stop'
			]);

			if(ldistance > 10 | rdistance < 10) {
				condition(robotCommand=='moveReverse');
				factor(delay); // want to move back longer
			} else {
				condition(robotCommand!='moveReverse');
			}

			// predict new position
			var newpos = updatePosition(position, robotCommand, delay);
			
			factor(-Math.abs(newpos.x));
			factor(-Math.abs(newpos.y));

			return [robotCommand, delay, newpos];
		}
	);

	var commands = sample(marginalCommandsDist);
	var newPositionDist = Infer({method:'enumerate'}, function() {return sample(marginalCommandsDist)[2]});

	var robotCommand = commands[0];
	var delay = commands[1];
	console.log(robotCommand);
	console.log(delay);
	console.log("getLeftDistance: " + ldistance);
	console.log("getRightDistance: " + rdistance);

	// actually move
	display(robotCommand + ' for ' + delay + 's');
	var robotMovement = robot[robotCommand];
	robotMovement(delay);

	// continue
	move(n-1, newPositionDist);
};

move(20);

// var turnRight = robot.turnRight;
// turnRight(8.75);
// // var turnLeft = robot.turnLeft;
// // turnLeft(8.5);

var stop = robot.stop;
stop();

=======
// var autonomous = robot.autonomous;

var move = function() {
	var delay = randomInteger(10)+1;
	var direction = uniformDraw([
			'moveForward',
			'turnRight',
			'turnLeft',
			'moveReverse',
			'stop'
		])
	display(direction + ' for ' + delay + 's');
	var nextMove = (robot[direction])();
	robot.sleep(1);
	return "finished";

};

move();
move();
move();
move();
>>>>>>> Stashed changes

// display('connected');
// var moveForward = robot.moveForward;
// display('moveForward defined');
// moveForward();
// display('moveForward');
// moveForward();
// display('moveForward');
// moveForward();
// display('moveForward');

"finished";