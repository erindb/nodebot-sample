// webppl robot.wppl --require robot

display('start');

var connect = robot.connect;
var stop = robot.stop;
var sendPosition = robot.sendPosition;

connect();

var printLocationEstimate = function(positionDist) {
	// var discretizedLocation = Infer(
	// 	{method:'enumerate'},
	// 	function() {
	// 		var pos = sample(positionDist);
	// 		return {
	// 			x: Math.round(pos.x/10),
	// 			y: Math.round(pos.y/10)
	// 		}
	// 	}
	// );
	// map(function(x) {
	// 	display(
	// 		map(function(y) {
	// 			var pos = {x: x, y: y};
	// 			return (Math.round(Math.exp(discretizedLocation.score(pos))*100)/100).toFixed(2);
	// 		}, robot.range(5, -5)).join(' ')
	// 	);
	// }, robot.range(-5, 5));
	var pos = sample(positionDist);
	sendPosition({x: pos.x, y: pos.y});

	// display(discretizedLocation.support());
};

var getLeftDistance = robot.getLeftDistance;
var getRightDistance = robot.getRightDistance;
var secPerFullTurn = 8.75;
var turnPerSec = secPerFullTurn / (2*Math.PI);
var cmPerSec = 8;
var xnoise = 3;
var ynoise = 3;
var thetanoise = 3;

var updatePosition = function(position, robotCommand, delay) {
	if (robotCommand=='moveForward') {
		return {
			x: Math.round((position.x + Math.cos(position.theta)*delay*cmPerSec)*100)/100,
			y: Math.round((position.y + Math.sin(position.theta)*delay*cmPerSec)*100)/100,
			theta: Math.round(position.theta*100)/100
		}
	} else if (robotCommand=='moveReverse') {
		return {
			x: Math.round((position.x + Math.cos(position.theta)*delay*cmPerSec)*100)/100,
			y: Math.round((position.y + Math.sin(position.theta)*delay*cmPerSec)*100)/100,
			theta: Math.round(position.theta*100)/100
		}
	} else if (robotCommand=='turnLeft') {
		return {
			x: position.x,
			y: position.y,
			theta: Math.round(((position.theta + turnPerSec*delay) % (2*Math.PI))*100)/100
		}
	} else if (robotCommand=='turnRight') {
		return {
			x: position.x,
			y: position.y,
			theta: Math.round(((position.theta - turnPerSec*delay) % (2*Math.PI))*100)/100
		}
	} else {
		return position;
	}
}

var robotCommandPrior = function() {
		categorical(
			[2,1,1,1,0//.5
			], // weights on possible commands
			['moveForward',
			'turnRight',
			'turnLeft',
			'moveReverse',
			'stop'
		]);
}


var initialPosDist = Infer({method: 'enumerate'}, function() {return {x:0, y:0, theta:0}});

var autonomous = function(positionDist) {
	var positionDist = positionDist?positionDist:initialPosDist;
	var ldistance = getLeftDistance();
	var rdistance = getRightDistance();

	printLocationEstimate(positionDist);

	var commands = sample(Infer(
		{method: 'enumerate'},
		function() {
			var position = sample(positionDist);
			var robotCommand = robotCommandPrior();

			// sample robot commands
			var delay = (randomInteger(10)+1)/10;

			if(ldistance > 10 | rdistance < 10) {
				condition(robotCommand=='moveReverse');
				condition(delay==1);
				// factor(delay); // want to move back longer
			} else {
				condition(robotCommand!='moveReverse');
			}

			// predict new position
			var newpos = updatePosition(position, robotCommand, delay);
			
			// factor(-Math.abs(newpos.x));
			// factor(-Math.abs(newpos.y));

			return [robotCommand, delay];
		}
	));

	var robotCommand = commands[0];
	var delay = commands[1];

	var newPositionDist = Infer(
		{method:'MCMC', samples: 100},
		function() {
			var currentPosition = sample(positionDist);
			var nextPosition = updatePosition(currentPosition, robotCommand, delay);
			return {
				x: gaussian(nextPosition.x, xnoise),
				y: gaussian(nextPosition.y, ynoise),
				theta: gaussian(nextPosition.theta, thetanoise)
			};
		}
	);

	var robotMovement = robot[robotCommand];
	robotMovement(delay);
	stop(0.1);

	// continue
	autonomous(newPositionDist);
};

autonomous();

stop();

"finished";