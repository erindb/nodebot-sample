display('start');

var connect = robot.connect;
connect();

var secPerFullTurn = 10;
var turnPerSec = secPerFullTurn / (2*Math.PI);

var updatePosition = function(position, robotCommand, delay) {
	if (robotCommand=='moveForward') {
		return {
			x: position.x + Math.cos(position.theta),
			y: position.y + Math.sin(position.theta),
			theta: position.theta
		}
	} else if (robotCommand=='moveReverse') {
		return {
			x: position.x + Math.cos(position.theta),
			y: position.y + Math.sin(position.theta),
			theta: position.theta
		}
	} else if (robotCommand=='turnLeft') {
		return {
			x: position.x,
			y: position.y,
			theta: position.theta + turnPerSec*delay
		}
	} else if (robotCommand=='turnRight') {
		return {
			x: position.x,
			y: position.y,
			theta: position.theta - turnPerSec*delay
		}
	} else {
		return position;
	}
}

var move = function(n, position) {
	var position = position?position:{x:0, y:0, theta:0};

	// var commands = Infer(
	// 	{method: 'rejection'},
	// 	function() {
			// sample robot commands
			var delay = randomInteger(5)+1;
			var robotCommand = uniformDraw([
				'moveForward',
				'turnRight',
				'turnLeft',
				'moveReverse',
				'stop'
			]);

			// predict new position
			var newpos = updatePosition(position, robotCommand, delay);
			
	// 		return [robotCommand, delay, newpos];
	// 	}
	// )

	// var robotCommand = commands[0];
	// var delay = commands[1];
	// var newpos = commands[2]
	console.log(newpos);

	// actually move
	display(robotCommand + ' for ' + delay + 's');
	var robotMovement = robot[robotCommand];
	robotMovement(delay);

	// continue
	move(n-1, newpos);
};

move(20);

// display('connected');
// var moveForward = robot.moveForward;
// display('moveForward defined');
// moveForward();
// display('moveForward');
// moveForward();
// display('moveForward');
// moveForward();
// display('moveForward');

"finished";